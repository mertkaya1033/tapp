{"version":3,"sources":["api/constants/index.ts","api/reducers/utils.ts","api/reducers/status.ts","api/reducers/ddahs.ts","api/reducers/globals.ts","dynamic-entry-router.tsx","api/reducers/assignments.ts","api/reducers/sessions.ts","api/reducers/positions.ts","api/reducers/instructors.ts","api/reducers/applicants.ts","api/reducers/applications.ts","api/reducers/contract_templates.ts","api/reducers/postings.ts","api/reducers/posting_positions.ts","api/reducers/users.ts","views/admin/offertable/constants.ts","views/admin/ddah-table/constants.tsx","views/admin/positions/constants.ts","views/admin/offertable/reducers.ts","views/admin/ddah-table/reducers.tsx","views/admin/positions/reducers.ts","rootReducer.ts","store.js","index.tsx"],"names":["API_INTERACTION_START","API_INTERACTION_END","FETCH_SESSIONS_SUCCESS","FETCH_ONE_SESSION_SUCCESS","UPSERT_ONE_SESSION_SUCCESS","DELETE_ONE_SESSION_SUCCESS","SET_ACTIVE_SESSION","FETCH_INSTRUCTORS_SUCCESS","FETCH_ONE_INSTRUCTOR_SUCCESS","UPSERT_ONE_INSTRUCTOR_SUCCESS","DELETE_ONE_INSTRUCTOR_SUCCESS","FETCH_POSITIONS_SUCCESS","FETCH_ONE_POSITION_SUCCESS","UPSERT_ONE_POSITION_SUCCESS","DELETE_ONE_POSITION_SUCCESS","FETCH_ASSIGNMENTS_SUCCESS","FETCH_ONE_ASSIGNMENT_SUCCESS","UPSERT_ONE_ASSIGNMENT_SUCCESS","DELETE_ONE_ASSIGNMENT_SUCCESS","FETCH_ONE_OFFER_SUCCESS","SET_OFFER_ACCEPTED_SUCCESS","SET_OFFER_REJECTED_SUCCESS","OFFER_CREATE_SUCCESS","OFFER_EMAIL_SUCCESS","OFFER_NAG_SUCCESS","OFFER_WITHDRAW_SUCCESS","FETCH_CONTRACT_TEMPLATES_SUCCESS","FETCH_ONE_CONTRACT_TEMPLATE_SUCCESS","UPSERT_ONE_CONTRACT_TEMPLATE_SUCCESS","DELETE_ONE_CONTRACT_TEMPLATE_SUCCESS","FETCH_ALL_CONTRACT_TEMPLATES_SUCCESS","FETCH_APPLICATIONS_SUCCESS","FETCH_ONE_APPLICATION_SUCCESS","UPSERT_ONE_APPLICATION_SUCCESS","DELETE_ONE_APPLICATION_SUCCESS","FETCH_WAGE_CHUNKS_FOR_ASSIGNMENT_SUCCESS","UPSERT_WAGE_CHUNKS_FOR_ASSIGNMENT_SUCCESS","FETCH_OFFERS_FOR_ASSIGNMENT_SUCCESS","UPSERT_OFFERS_FOR_ASSIGNMENT_SUCCESS","UPSERT_ONE_WAGE_CHUNK_SUCCESS","DELETE_ONE_WAGE_CHUNK_SUCCESS","FETCH_APPLICANTS_SUCCESS","FETCH_ONE_APPLICANT_SUCCESS","UPSERT_ONE_APPLICANT_SUCCESS","DELETE_ONE_APPLICANT_SUCCESS","FETCH_ACTIVE_USER_SUCCESS","SET_ACTIVE_USER_ROLE_SUCCESS","FETCH_USERS_SUCCESS","UPSERT_USERS_SUCCESS","FETCH_DDAHS_SUCCESS","FETCH_ONE_DDAH_SUCCESS","UPSERT_ONE_DDAH_SUCCESS","DELETE_ONE_DDAH_SUCCESS","DDAH_APPROVE_SUCCESS","DDAH_EMAIL_SUCCESS","FETCH_POSTINGS_SUCCESS","FETCH_ONE_POSTING_SUCCESS","UPSERT_ONE_POSTING_SUCCESS","DELETE_ONE_POSTING_SUCCESS","FETCH_POSTING_POSITIONS_SUCCESS","FETCH_ONE_POSTING_POSITION_SUCCESS","UPSERT_ONE_POSTING_POSITION_SUCCESS","DELETE_ONE_POSTING_POSITION_SUCCESS","SET_GLOBALS","upsertItem","modelData","newItem","didUpdate","newModelData","map","item","id","push","createBasicReducerObject","FETCH_MANY","FETCH_ONE","UPSERT_ONE","DELETE_ONE","state","action","_modelData","payload","deletedItem","filter","createReducer","initialState","handlers","path","_storePath","Math","random","pushToPath","dir","unshift","reducer","_origCreateReducer","_localStoreSelector","localState","e","console","error","createLocalStoreSelector","combineReducers","model","pushToPathCallbacks","Object","entries","newReducer","_origCombineReducers","func","statusReducer","ongoingInteraction","ongoingInteractionsList","i","length","basicReducers","ddahsReducer","globalReducer","MainEntry","React","lazy","PublicEntry","DynamicEntryRouter","publicRoute","useRouteMatch","content","Fragment","fallback","setWageChunks","assignmentId","assignment_id","_wageChunksByAssignmentId","setOffers","_offersByAssignmentId","offers","assignmentsReducer","sessionsReducer","activeSession","positionsReducer","instructorsReducer","applicantsReducer","applicationsReducer","contractTemplatesReducer","all","postingsReducer","position_id","posting_id","postingPositionsReducer","usersReducer","users","active_user","active_role","SET_SELECTED_ROWS","SET_SELECTED_DDAH_TABLE_ROWS","SET_SELECTED_POSITION","offerTableReducer","selectedAssignmentIds","ddahsTableReducer","selectedDdahIds","positionsTableReducer","selectedPositionIds","status","sessions","positions","applicants","applications","assignments","instructors","contractTemplates","postings","postingPositions","ddahs","ui","notifications","notificationReducer","offerTable","ddahsTable","positionsTable","globals","configureStore","persistConfig","key","storage","whitelist","persistedReducer","persistReducer","rootReducer","store","createStore","composeWithDevTools","applyMiddleware","thunk","persistor","persistStore","DevFrame","props","children","FullDevFrame","a","then","module","default","Suspense","render","Component","ReactDOM","document","getElementById","hot","accept","NextApp","require"],"mappings":"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","file":"static/js/main.7bdf707f.chunk.js","sourcesContent":["export const API_INTERACTION_START = \"API_INTERACTION_START\";\nexport const API_INTERACTION_END = \"API_INTERACTION_END\";\n\n/* Constants were batch-created with the following code:\n\n    let wrap = x => x.map(y => `export const ${y} = \"${y}\";`);\n    console.log(\n        [\n            \"session\",\n            \"instructor\",\n            \"position\",\n            \"assignment\",\n            \"offer\",\n            \"contract_template\",\n            \"application\",\n            \"wage_chunk\"\n        ]\n            .map(x => {\n                x = x.toUpperCase();\n                return [`// \\`${x.toLowerCase()}\\`-related constants`]\n                    .concat(\n                        wrap([\n                            `FETCH_${x}S_SUCCESS`,\n                            `FETCH_ONE_${x}_SUCCESS`,\n                            `UPSERT_ONE_${x}_SUCCESS`,\n                            `DELETE_ONE_${x}_SUCCESS`\n                        ])\n                    )\n                    .join(\"\\n\");\n            })\n            .join(\"\\n\\n\")\n    );\n*/\n\n// `session`-related constants\nexport const FETCH_SESSIONS_SUCCESS = \"FETCH_SESSIONS_SUCCESS\";\nexport const FETCH_ONE_SESSION_SUCCESS = \"FETCH_ONE_SESSION_SUCCESS\";\nexport const UPSERT_ONE_SESSION_SUCCESS = \"UPSERT_ONE_SESSION_SUCCESS\";\nexport const DELETE_ONE_SESSION_SUCCESS = \"DELETE_ONE_SESSION_SUCCESS\";\nexport const SET_ACTIVE_SESSION = \"SET_ACTIVE_SESSION\";\n\n// `instructor`-related constants\nexport const FETCH_INSTRUCTORS_SUCCESS = \"FETCH_INSTRUCTORS_SUCCESS\";\nexport const FETCH_ONE_INSTRUCTOR_SUCCESS = \"FETCH_ONE_INSTRUCTOR_SUCCESS\";\nexport const UPSERT_ONE_INSTRUCTOR_SUCCESS = \"UPSERT_ONE_INSTRUCTOR_SUCCESS\";\nexport const DELETE_ONE_INSTRUCTOR_SUCCESS = \"DELETE_ONE_INSTRUCTOR_SUCCESS\";\n\n// `position`-related constants\nexport const FETCH_POSITIONS_SUCCESS = \"FETCH_POSITIONS_SUCCESS\";\nexport const FETCH_ONE_POSITION_SUCCESS = \"FETCH_ONE_POSITION_SUCCESS\";\nexport const UPSERT_POSITIONS_SUCCESS = \"UPSERT_POSITIONS_SUCCESS\";\nexport const UPSERT_ONE_POSITION_SUCCESS = \"UPSERT_ONE_POSITION_SUCCESS\";\nexport const DELETE_ONE_POSITION_SUCCESS = \"DELETE_ONE_POSITION_SUCCESS\";\n\n// `assignment`-related constants\nexport const FETCH_ASSIGNMENTS_SUCCESS = \"FETCH_ASSIGNMENTS_SUCCESS\";\nexport const FETCH_ONE_ASSIGNMENT_SUCCESS = \"FETCH_ONE_ASSIGNMENT_SUCCESS\";\nexport const UPSERT_ONE_ASSIGNMENT_SUCCESS = \"UPSERT_ONE_ASSIGNMENT_SUCCESS\";\nexport const DELETE_ONE_ASSIGNMENT_SUCCESS = \"DELETE_ONE_ASSIGNMENT_SUCCESS\";\n\n// `offer`-related constants\nexport const FETCH_OFFERS_SUCCESS = \"FETCH_OFFERS_SUCCESS\";\nexport const FETCH_ONE_OFFER_SUCCESS = \"FETCH_ONE_OFFER_SUCCESS\";\nexport const UPSERT_ONE_OFFER_SUCCESS = \"UPSERT_ONE_OFFER_SUCCESS\";\nexport const DELETE_ONE_OFFER_SUCCESS = \"DELETE_ONE_OFFER_SUCCESS\";\nexport const SET_OFFER_ACCEPTED_SUCCESS = \"SET_OFFER_ACCEPTED_SUCCESS\";\nexport const SET_OFFER_REJECTED_SUCCESS = \"SET_OFFER_REJECTED_SUCCESS\";\nexport const OFFER_CREATE_SUCCESS = \"OFFER_CREATE_SUCCESS\";\nexport const OFFER_EMAIL_SUCCESS = \"OFFER_EMAIL_SUCCESS\";\nexport const OFFER_NAG_SUCCESS = \"OFFER_NAG_SUCCESS\";\nexport const OFFER_WITHDRAW_SUCCESS = \"OFFER_WITHDRAW_SUCCESS\";\n\n// `contract_template`-related constants\nexport const FETCH_CONTRACT_TEMPLATES_SUCCESS =\n    \"FETCH_CONTRACT_TEMPLATES_SUCCESS\";\nexport const FETCH_ONE_CONTRACT_TEMPLATE_SUCCESS =\n    \"FETCH_ONE_CONTRACT_TEMPLATE_SUCCESS\";\nexport const UPSERT_ONE_CONTRACT_TEMPLATE_SUCCESS =\n    \"UPSERT_ONE_CONTRACT_TEMPLATE_SUCCESS\";\nexport const DELETE_ONE_CONTRACT_TEMPLATE_SUCCESS =\n    \"DELETE_ONE_CONTRACT_TEMPLATE_SUCCESS\";\nexport const FETCH_ALL_CONTRACT_TEMPLATES_SUCCESS =\n    \"FETCH_ALL_CONTRACT_TEMPLATES_SUCCESS\";\n\n// `application`-related constants\nexport const FETCH_APPLICATIONS_SUCCESS = \"FETCH_APPLICATIONS_SUCCESS\";\nexport const FETCH_ONE_APPLICATION_SUCCESS = \"FETCH_ONE_APPLICATION_SUCCESS\";\nexport const UPSERT_ONE_APPLICATION_SUCCESS = \"UPSERT_ONE_APPLICATION_SUCCESS\";\nexport const DELETE_ONE_APPLICATION_SUCCESS = \"DELETE_ONE_APPLICATION_SUCCESS\";\n\n// `wage_chunk`-related constants\nexport const FETCH_WAGE_CHUNKS_SUCCESS = \"FETCH_WAGE_CHUNKS_SUCCESS\";\nexport const FETCH_WAGE_CHUNKS_FOR_ASSIGNMENT_SUCCESS =\n    \"FETCH_WAGE_CHUNKS_FOR_ASSIGNMENT_SUCCESS\";\nexport const UPSERT_WAGE_CHUNKS_FOR_ASSIGNMENT_SUCCESS =\n    \"UPSERT_WAGE_CHUNKS_FOR_ASSIGNMENT_SUCCESS\";\nexport const FETCH_OFFERS_FOR_ASSIGNMENT_SUCCESS =\n    \"FETCH_OFFERS_FOR_ASSIGNMENT_SUCCESS\";\nexport const UPSERT_OFFERS_FOR_ASSIGNMENT_SUCCESS =\n    \"UPSERT_OFFERS_FOR_ASSIGNMENT_SUCCESS\";\nexport const FETCH_ONE_WAGE_CHUNK_SUCCESS = \"FETCH_ONE_WAGE_CHUNK_SUCCESS\";\nexport const UPSERT_ONE_WAGE_CHUNK_SUCCESS = \"UPSERT_ONE_WAGE_CHUNK_SUCCESS\";\nexport const DELETE_ONE_WAGE_CHUNK_SUCCESS = \"DELETE_ONE_WAGE_CHUNK_SUCCESS\";\n\n// `applicant`-related constants\nexport const FETCH_APPLICANTS_SUCCESS = \"FETCH_APPLICANTS_SUCCESS\";\nexport const FETCH_ONE_APPLICANT_SUCCESS = \"FETCH_ONE_APPLICANT_SUCCESS\";\nexport const UPSERT_ONE_APPLICANT_SUCCESS = \"UPSERT_ONE_APPLICANT_SUCCESS\";\nexport const DELETE_ONE_APPLICANT_SUCCESS = \"DELETE_ONE_APPLICANT_SUCCESS\";\n\n// `user`/`active_user` constants\nexport const FETCH_ACTIVE_USER_SUCCESS = \"FETCH_ACTIVE_USER_SUCCESS\";\nexport const SET_ACTIVE_USER_ROLE_SUCCESS = \"SET_ACTIVE_USER_ROLE_SUCCESS\";\nexport const FETCH_USERS_SUCCESS = \"FETCH_USERS_SUCCESS\";\nexport const UPSERT_USERS_SUCCESS = \"UPSERT_USERS_SUCCESS\";\n\n// `ddah`-related constants\nexport const FETCH_DDAHS_SUCCESS = \"FETCH_DDAHS_SUCCESS\";\nexport const FETCH_ONE_DDAH_SUCCESS = \"FETCH_ONE_DDAH_SUCCESS\";\nexport const UPSERT_ONE_DDAH_SUCCESS = \"UPSERT_ONE_DDAH_SUCCESS\";\nexport const DELETE_ONE_DDAH_SUCCESS = \"DELETE_ONE_DDAH_SUCCESS\";\nexport const DDAH_APPROVE_SUCCESS = \"DDAH_APPROVE_SUCCESS\";\nexport const DDAH_EMAIL_SUCCESS = \"DDAH_EMAIL_SUCCESS\";\nexport const DDAH_ACCEPT_SUCCESS = \"DDAH_ACCEPT_SUCCESS\";\nexport const DDAH_REJECT_SUCCESS = \"DDAH_REJECT_SUCCESS\";\n\n// `posting`-related constants\nexport const FETCH_POSTINGS_SUCCESS = \"FETCH_POSTINGS_SUCCESS\";\nexport const FETCH_ONE_POSTING_SUCCESS = \"FETCH_ONE_POSTING_SUCCESS\";\nexport const UPSERT_ONE_POSTING_SUCCESS = \"UPSERT_ONE_POSTING_SUCCESS\";\nexport const DELETE_ONE_POSTING_SUCCESS = \"DELETE_ONE_POSTING_SUCCESS\";\n\n// `posting_position`-related constants\nexport const FETCH_POSTING_POSITIONS_SUCCESS =\n    \"FETCH_POSTING_POSITIONS_SUCCESS\";\nexport const FETCH_ONE_POSTING_POSITION_SUCCESS =\n    \"FETCH_ONE_POSTING_POSITION_SUCCESS\";\nexport const UPSERT_ONE_POSTING_POSITION_SUCCESS =\n    \"UPSERT_ONE_POSTING_POSITION_SUCCESS\";\nexport const DELETE_ONE_POSTING_POSITION_SUCCESS =\n    \"DELETE_ONE_POSTING_POSITION_SUCCESS\";\n\n// `debug` constants\nexport const DEBUG_SET_ACTIVE_USER_SUCCESS = \"DEBUG_SET_ACTIVE_USER_SUCCESS\";\n\n// global constants\nexport const SET_GLOBALS = \"SET_GLOBALS\";\n","/*\n * A set of utility functions to help with creating reducers\n */\n\nimport { combineReducers as _origCombineReducers } from \"redux\";\nimport { createReducer as _origCreateReducer } from \"redux-create-reducer\";\nimport type { Action, AnyAction, Reducer } from \"redux\";\nimport type { Selector } from \"reselect\";\n\ntype HasIdField = { id: number };\nexport interface HasPayload<T> extends AnyAction {\n    payload: T;\n}\n//export type HasPayload<T> = { payload: T } & AnyAction;\nexport type BasicState<T> = { _modelData: T[] };\nexport type TaggedState<T> = BasicState<T> & { _storePath: _StorePath };\ntype Handlers<State> = {\n    [key: string]: (state: State, action: any) => State;\n};\n\ntype _StorePath = {\n    id: number;\n    path: (string | number)[];\n};\ninterface _StorePathWithPushToPath extends _StorePath {\n    pushToPath: (dir: string | number) => void;\n}\ninterface TaggedReducer<State, A extends Action = AnyAction>\n    extends Reducer<State, A> {\n    _storePath: _StorePathWithPushToPath;\n}\n\ninterface TaggedReducerWithSelector<State> extends TaggedReducer<State> {\n    _localStoreSelector: Selector<any, State>;\n}\n\ntype TaggedReducersMapObject<State, A extends Action = AnyAction> = {\n    [K in keyof State & string]: TaggedReducer<State[K], A>;\n};\n\n/**\n * Either updates the item `modelData`\n * with id == newItem.id, or appends it.\n *\n * @returns {object} An updated version of modelData\n */\nexport function upsertItem<T extends HasIdField>(\n    modelData: T[],\n    newItem: T\n): T[] {\n    let didUpdate = false;\n    const newModelData = modelData.map((item) => {\n        if (item.id === newItem.id) {\n            didUpdate = true;\n            return newItem;\n        }\n        return item;\n    });\n    if (!didUpdate) {\n        newModelData.push(newItem);\n    }\n    return newModelData;\n}\n\n/**\n * Create a basic reducer for the operations\n *   FETCH_MANY\n *   FETCH_ONE\n *   UPSERT_ONE\n *   DELETE_ONE\n * A basic reducer assumes that `state._modelData` is\n * an array and that each item in that array has an `id`\n * that can be used to determine upserts and deletes, etc..\n *\n * @returns An object of reducers suitable for passing to `createReducer`\n */\nexport function createBasicReducerObject<T extends HasIdField>(\n    FETCH_MANY: string,\n    FETCH_ONE: string,\n    UPSERT_ONE: string,\n    DELETE_ONE: string\n) {\n    return {\n        [FETCH_MANY]: (state: BasicState<T>, action: HasPayload<T[]>) => ({\n            ...state,\n            _modelData: action.payload,\n        }),\n        [FETCH_ONE]: (state: BasicState<T>, action: HasPayload<T>) => ({\n            ...state,\n            _modelData: upsertItem(state._modelData, action.payload),\n        }),\n        [UPSERT_ONE]: (state: BasicState<T>, action: HasPayload<T>) => ({\n            ...state,\n            _modelData: upsertItem(state._modelData, action.payload),\n        }),\n        [DELETE_ONE]: (state: BasicState<T>, action: HasPayload<T>) => {\n            const deletedItem = action.payload;\n            return {\n                ...state,\n                _modelData: state._modelData.filter(\n                    (item) => item.id !== deletedItem.id\n                ),\n            };\n        },\n    };\n}\n\n/**\n * Wraps \"redux-create-reducer\"'s version of `createReducer` to add\n * a `_storePath` attribute to the initial state and the reducer.\n * `_storePath` is used by `localStoreSelector` to return the local\n * state when passed in the global state. (For example, if\n *    `state = { a: b: localState }`, then `localStoreSelector(state) === localState`.)\n *\n * @param {object} initialState\n * @param {object} handlers\n * @returns\n */\nexport function createReducer<State>(\n    initialState: State,\n    handlers: Handlers<State>\n) {\n    const path: (string | number)[] = [];\n    function pushToPath(dir: string | number) {\n        path.unshift(dir);\n    }\n    // Every isolated state should have a unique id, so generate\n    // a random one.\n    const _storePath: _StorePathWithPushToPath = {\n        id: Math.random(),\n        path,\n        pushToPath,\n    };\n\n    // add _storePath to the initial state and to the\n    // new reducer\n    ((initialState as unknown) as TaggedState<unknown>)._storePath = _storePath;\n    const reducer = _origCreateReducer(\n        initialState,\n        handlers as any\n    ) as TaggedReducerWithSelector<typeof initialState>;\n    reducer._storePath = _storePath;\n\n    // For convenience, attach a local store selector to the reducer\n    reducer._localStoreSelector = (createLocalStoreSelector<State>(\n        _storePath\n    ) as unknown) as Selector<State, State>;\n\n    return reducer;\n}\n\n/**\n * Search `state` for a local state in the location of `_storePath.path`.\n * For example, if `_storePath.path = [\"a\", \"b\"]`, this function will\n * return `state.a.b`.\n *\n * @param {object} state Redux state\n * @param {object} _storePath The `_storePath` object to use for searching `state`\n * @returns\n */\nfunction _localStoreSelector<T>(\n    state: TaggedState<T> | any,\n    _storePath: _StorePath\n): TaggedState<T> {\n    if (state._storePath && state._storePath.id === _storePath.id) {\n        return state;\n    }\n    try {\n        let localState = state;\n        for (const dir of _storePath.path) {\n            localState = localState[dir];\n        }\n        return localState;\n    } catch (e) {\n        // eslint-disable-next-line\n        console.error(\n            \"Searching\",\n            state,\n            \"for local state with path\",\n            _storePath,\n            \"but encountered an error\"\n        );\n    }\n    return state;\n}\n\n/**\n * Create a selector that, when passed in the global redux state, will search\n * and return a local state based on the information in `_storePath`. This selector\n * can be passed either the local state or the global state. If it is passed the local\n * state, it checks that the `state._storePath.id` field matches `_storePath.id`;\n * if so, this selector immediately returns `state`. Otherwise, use `_storePath.path`\n * to search for the local state. For example, if `_storePath.path = [\"a\", \"b\"]`,\n * the returned selector will return `state.a.b`.\n *\n * @export\n * @param _storePath\n * @param _storePath.path The path to search in the redux state\n * @param _storePath.id The unique id of the local state\n * @returns {Function} A selector that returns the local state (based on `_storePath`) when passed the global state\n */\nexport function createLocalStoreSelector<T>(_storePath: _StorePath) {\n    return (state: any) => _localStoreSelector<T>(state, _storePath);\n}\n\n/**\n * Wraps \"redux\"'s `combineReducers` function so that `reducer._storePath.pushToPath`\n * is called on all child reducers.\n *\n * Redux's `combineReducers` function creates a new reducer from `model` that dispatches\n * actions to all reducers listed in `model`, but passes them an isolated part of the\n * store instead of passing in the full redux store as `state`. This is great for writing\n * reducers, but it makes things complicated for writing selectors, since, in general,\n * a selector will get passed the whole state, not the isolated part of the state that\n * `combineReducers` supplies. This wrapped version of `combineReducers` adds to a `path`\n * variable that is present in each reducer and which can be passed to a smart selector.\n *\n * @export\n * @param model An object whose values are reducers\n * @returns  A reducer\n */\nexport function combineReducers<T extends TaggedReducersMapObject<S>, S>(\n    model: T\n) {\n    const pushToPathCallbacks: Function[] = [];\n    // recursively call all `pushToPath` functions.\n    // They have been stored in `pushToPathCallbacks`\n    function pushToPath(dir: string) {\n        for (const func of pushToPathCallbacks) {\n            func(dir);\n        }\n    }\n\n    for (const [dir, reducer] of Object.entries(model) as Array<\n        [keyof T & string, TaggedReducer<T>]\n    >) {\n        if (reducer._storePath) {\n            reducer._storePath.pushToPath(dir);\n            pushToPathCallbacks.push(reducer._storePath.pushToPath);\n        }\n    }\n\n    const newReducer = _origCombineReducers(model as any);\n    (newReducer as any)._storePath = { pushToPath };\n\n    return (newReducer as unknown) as TaggedReducer<\n        { [K in keyof T]: ReturnType<T[K]> }\n    >;\n}\n","import { createReducer, HasPayload } from \"./utils\";\nimport { API_INTERACTION_START, API_INTERACTION_END } from \"../constants\";\n\ntype Interaction = { id: string; message: string };\ninterface StatusState {\n    ongoingInteraction: boolean;\n    ongoingInteractionsList: Interaction[];\n}\nconst initialState: StatusState = {\n    ongoingInteraction: false,\n    ongoingInteractionsList: [],\n};\n\n// Keep a list of all ongoing interactions that are in progress.\n// This way we could display a spinner or some-such while interactions\n// are going on. Interactions will be mostly network-based interactions.\nexport const statusReducer = createReducer(initialState, {\n    [API_INTERACTION_START]: (state, action: HasPayload<Interaction>) => ({\n        ...state,\n        ongoingInteraction: true,\n        ongoingInteractionsList: [\n            ...state.ongoingInteractionsList,\n            action.payload,\n        ],\n    }),\n    [API_INTERACTION_END]: (state, action: HasPayload<{ id: string }>) => {\n        // remove the current interaction\n        const ongoingInteractionsList = state.ongoingInteractionsList.filter(\n            (i) => i.id !== action.payload.id\n        );\n        return {\n            ...state,\n            ongoingInteraction: ongoingInteractionsList.length > 0,\n            ongoingInteractionsList: ongoingInteractionsList,\n        };\n    },\n});\n","import {\n    FETCH_DDAHS_SUCCESS,\n    FETCH_ONE_DDAH_SUCCESS,\n    UPSERT_ONE_DDAH_SUCCESS,\n    DELETE_ONE_DDAH_SUCCESS,\n} from \"../constants\";\nimport { RawDdah } from \"../defs/types\";\nimport { createBasicReducerObject, createReducer } from \"./utils\";\n\ninterface DdahState {\n    _modelData: RawDdah[];\n}\n\nconst initialState: DdahState = {\n    _modelData: [],\n};\n\n// basicReducers is an object whose keys are FETCH_SESSIONS_SUCCESS, etc,\n// and values are the corresponding reducer functions\nconst basicReducers = createBasicReducerObject<RawDdah>(\n    FETCH_DDAHS_SUCCESS,\n    FETCH_ONE_DDAH_SUCCESS,\n    UPSERT_ONE_DDAH_SUCCESS,\n    DELETE_ONE_DDAH_SUCCESS\n);\n\nexport const ddahsReducer = createReducer(initialState, basicReducers);\n","import { createReducer } from \"redux-create-reducer\";\nimport { SET_GLOBALS } from \"../constants\";\n\nexport const globalReducer = createReducer({} as Record<string, string>, {\n    [SET_GLOBALS]: (state, action) => ({\n        ...state,\n        ...action.payload,\n    }),\n});\n","import React, { Suspense } from \"react\";\nimport { useRouteMatch } from \"react-router\";\n\nconst MainEntry = React.lazy(() => import(\"./main-entry\"));\nconst PublicEntry = React.lazy(() => import(\"./public-entry\"));\n\n/**\n * Dynamically load the correct entry component based on the route string.\n *\n * @export\n * @returns\n */\nexport default function DynamicEntryRouter() {\n    const publicRoute = useRouteMatch(\"/public\");\n    let content = <MainEntry />;\n    if (publicRoute) {\n        content = <PublicEntry />;\n    }\n\n    return (\n        <React.Fragment>\n            <Suspense fallback=\"Loading...\">{content}</Suspense>\n        </React.Fragment>\n    );\n}\n","import {\n    FETCH_ASSIGNMENTS_SUCCESS,\n    FETCH_ONE_ASSIGNMENT_SUCCESS,\n    UPSERT_ONE_ASSIGNMENT_SUCCESS,\n    DELETE_ONE_ASSIGNMENT_SUCCESS,\n    FETCH_WAGE_CHUNKS_FOR_ASSIGNMENT_SUCCESS,\n    UPSERT_WAGE_CHUNKS_FOR_ASSIGNMENT_SUCCESS,\n    FETCH_OFFERS_FOR_ASSIGNMENT_SUCCESS,\n    UPSERT_OFFERS_FOR_ASSIGNMENT_SUCCESS,\n} from \"../constants\";\nimport { RawAssignment, RawOffer, RawWageChunk } from \"../defs/types\";\nimport { createBasicReducerObject, createReducer, HasPayload } from \"./utils\";\n\ninterface AssignmentState {\n    _modelData: RawAssignment[];\n    _wageChunksByAssignmentId: Record<number, RawWageChunk[]>;\n    _offersByAssignmentId: Record<number, RawOffer[]>;\n}\nconst initialState: AssignmentState = {\n    _modelData: [],\n    // Since we don't want to fetch all wage chunks all the time,\n    // we fetch them on a per-assignment basis and store them here.\n    _wageChunksByAssignmentId: {},\n    _offersByAssignmentId: {},\n};\n\n// basicReducers is an object whose keys are FETCH_SESSIONS_SUCCESS, etc,\n// and values are the corresponding reducer functions\nconst basicReducers = createBasicReducerObject<RawAssignment>(\n    FETCH_ASSIGNMENTS_SUCCESS,\n    FETCH_ONE_ASSIGNMENT_SUCCESS,\n    UPSERT_ONE_ASSIGNMENT_SUCCESS,\n    DELETE_ONE_ASSIGNMENT_SUCCESS\n);\n\n/**\n * Given a list of all the wage chunks for a particular assignment,\n * sets the _wageChunksByAssignmentId hash appropriately.\n *\n * @param {*} state\n * @param {{payload: object}} action\n * @returns\n */\nfunction setWageChunks(\n    state: AssignmentState,\n    action: HasPayload<RawWageChunk[]>\n): AssignmentState {\n    const assignmentId = (action.payload[0] || {}).assignment_id;\n    if (!assignmentId) {\n        return state;\n    }\n    return {\n        ...state,\n        _wageChunksByAssignmentId: {\n            ...state._wageChunksByAssignmentId,\n            [assignmentId]: action.payload,\n        },\n    };\n}\n\n/**\n * Given a list of all offers for a particular assignment,\n * sets the _offersByAssignmentId hash appropriately.\n *\n * @param {*} state\n * @param {{payload: object}} action\n * @returns\n */\nfunction setOffers(\n    state: AssignmentState,\n    action: HasPayload<{ assignment_id: number; offers: RawOffer[] }>\n): AssignmentState {\n    const assignmentId = action.payload.assignment_id;\n    if (!assignmentId) {\n        return state;\n    }\n    return {\n        ...state,\n        _offersByAssignmentId: {\n            ...state._offersByAssignmentId,\n            [assignmentId]: action.payload.offers,\n        },\n    };\n}\n\nexport const assignmentsReducer = createReducer(initialState, {\n    ...basicReducers,\n    // wage chunks are closely associated with assignments, so their actions happen\n    // here\n    [FETCH_WAGE_CHUNKS_FOR_ASSIGNMENT_SUCCESS]: setWageChunks,\n    [UPSERT_WAGE_CHUNKS_FOR_ASSIGNMENT_SUCCESS]: setWageChunks,\n    [FETCH_OFFERS_FOR_ASSIGNMENT_SUCCESS]: setOffers,\n    [UPSERT_OFFERS_FOR_ASSIGNMENT_SUCCESS]: setOffers,\n});\n","import {\n    FETCH_SESSIONS_SUCCESS,\n    FETCH_ONE_SESSION_SUCCESS,\n    UPSERT_ONE_SESSION_SUCCESS,\n    DELETE_ONE_SESSION_SUCCESS,\n    SET_ACTIVE_SESSION,\n} from \"../constants\";\nimport { createBasicReducerObject, createReducer } from \"./utils\";\nimport type { BasicState, HasPayload } from \"./utils\";\nimport { RawSession } from \"../defs/types\";\n\nexport type SessionState = BasicState<RawSession> & {\n    activeSession: RawSession | null;\n};\nconst initialState: SessionState = {\n    _modelData: [] as RawSession[],\n    activeSession: null,\n};\n\n// basicReducers is an object whose keys are FETCH_SESSIONS_SUCCESS, etc,\n// and values are the corresponding reducer functions\nconst basicReducers = createBasicReducerObject(\n    FETCH_SESSIONS_SUCCESS,\n    FETCH_ONE_SESSION_SUCCESS,\n    UPSERT_ONE_SESSION_SUCCESS,\n    DELETE_ONE_SESSION_SUCCESS\n);\n\nexport const sessionsReducer = createReducer<SessionState>(initialState, {\n    ...basicReducers,\n    [SET_ACTIVE_SESSION]: (\n        state: SessionState,\n        action: HasPayload<RawSession>\n    ): SessionState => ({\n        ...state,\n        activeSession: action.payload,\n    }),\n});\n","import {\n    FETCH_POSITIONS_SUCCESS,\n    FETCH_ONE_POSITION_SUCCESS,\n    UPSERT_ONE_POSITION_SUCCESS,\n    DELETE_ONE_POSITION_SUCCESS,\n} from \"../constants\";\nimport { RawPosition } from \"../defs/types\";\nimport { createBasicReducerObject, createReducer } from \"./utils\";\n\ninterface PositionState {\n    _modelData: RawPosition[];\n}\nconst initialState: PositionState = {\n    _modelData: [],\n};\n\n// basicReducers is an object whose keys are FETCH_SESSIONS_SUCCESS, etc,\n// and values are the corresponding reducer functions\nconst basicReducers = createBasicReducerObject<RawPosition>(\n    FETCH_POSITIONS_SUCCESS,\n    FETCH_ONE_POSITION_SUCCESS,\n    UPSERT_ONE_POSITION_SUCCESS,\n    DELETE_ONE_POSITION_SUCCESS\n);\n\nexport const positionsReducer = createReducer(initialState, basicReducers);\n","import {\n    FETCH_INSTRUCTORS_SUCCESS,\n    FETCH_ONE_INSTRUCTOR_SUCCESS,\n    UPSERT_ONE_INSTRUCTOR_SUCCESS,\n    DELETE_ONE_INSTRUCTOR_SUCCESS,\n} from \"../constants\";\nimport { RawInstructor } from \"../defs/types\";\nimport { createBasicReducerObject, createReducer } from \"./utils\";\n\ninterface InstructorState {\n    _modelData: RawInstructor[];\n}\nconst initialState: InstructorState = {\n    _modelData: [],\n};\n\n// basicReducers is an object whose keys are FETCH_SESSIONS_SUCCESS, etc,\n// and values are the corresponding reducer functions\nconst basicReducers = createBasicReducerObject<RawInstructor>(\n    FETCH_INSTRUCTORS_SUCCESS,\n    FETCH_ONE_INSTRUCTOR_SUCCESS,\n    UPSERT_ONE_INSTRUCTOR_SUCCESS,\n    DELETE_ONE_INSTRUCTOR_SUCCESS\n);\n\nexport const instructorsReducer = createReducer(initialState, basicReducers);\n","import {\n    FETCH_APPLICANTS_SUCCESS,\n    FETCH_ONE_APPLICANT_SUCCESS,\n    UPSERT_ONE_APPLICANT_SUCCESS,\n    DELETE_ONE_APPLICANT_SUCCESS,\n} from \"../constants\";\nimport { RawApplicant } from \"../defs/types\";\nimport { createBasicReducerObject, createReducer } from \"./utils\";\n\nexport interface ApplicantsState {\n    _modelData: RawApplicant[];\n}\nconst initialState: ApplicantsState = {\n    _modelData: [],\n};\n\n// basicReducers is an object whose keys are FETCH_SESSIONS_SUCCESS, etc,\n// and values are the corresponding reducer functions\nconst basicReducers = createBasicReducerObject<RawApplicant>(\n    FETCH_APPLICANTS_SUCCESS,\n    FETCH_ONE_APPLICANT_SUCCESS,\n    UPSERT_ONE_APPLICANT_SUCCESS,\n    DELETE_ONE_APPLICANT_SUCCESS\n);\n\nexport const applicantsReducer = createReducer(initialState, basicReducers);\n","import {\n    FETCH_APPLICATIONS_SUCCESS,\n    FETCH_ONE_APPLICATION_SUCCESS,\n    UPSERT_ONE_APPLICATION_SUCCESS,\n    DELETE_ONE_APPLICATION_SUCCESS,\n} from \"../constants\";\nimport { RawApplication } from \"../defs/types\";\nimport { createBasicReducerObject, createReducer } from \"./utils\";\n\ninterface ApplicationState {\n    _modelData: RawApplication[];\n}\nconst initialState: ApplicationState = {\n    _modelData: [],\n};\n\n// basicReducers is an object whose keys are FETCH_SESSIONS_SUCCESS, etc,\n// and values are the corresponding reducer functions\nconst basicReducers = createBasicReducerObject<RawApplication>(\n    FETCH_APPLICATIONS_SUCCESS,\n    FETCH_ONE_APPLICATION_SUCCESS,\n    UPSERT_ONE_APPLICATION_SUCCESS,\n    DELETE_ONE_APPLICATION_SUCCESS\n);\n\nexport const applicationsReducer = createReducer(initialState, basicReducers);\n","import {\n    FETCH_CONTRACT_TEMPLATES_SUCCESS,\n    FETCH_ONE_CONTRACT_TEMPLATE_SUCCESS,\n    UPSERT_ONE_CONTRACT_TEMPLATE_SUCCESS,\n    DELETE_ONE_CONTRACT_TEMPLATE_SUCCESS,\n    FETCH_ALL_CONTRACT_TEMPLATES_SUCCESS,\n} from \"../constants\";\nimport { RawContractTemplate } from \"../defs/types\";\nimport { createBasicReducerObject, createReducer, HasPayload } from \"./utils\";\n\ninterface ContractTemplateState {\n    _modelData: RawContractTemplate[];\n    all: { template_file: string }[];\n}\n\nconst initialState: ContractTemplateState = {\n    _modelData: [],\n    all: [],\n};\n\n// basicReducers is an object whose keys are FETCH_*_SUCCESS, etc,\n// and values are the corresponding reducer functions\nconst basicReducers = createBasicReducerObject<RawContractTemplate>(\n    FETCH_CONTRACT_TEMPLATES_SUCCESS,\n    FETCH_ONE_CONTRACT_TEMPLATE_SUCCESS,\n    UPSERT_ONE_CONTRACT_TEMPLATE_SUCCESS,\n    DELETE_ONE_CONTRACT_TEMPLATE_SUCCESS\n);\n\nexport const contractTemplatesReducer = createReducer(initialState, {\n    ...basicReducers,\n    [FETCH_ALL_CONTRACT_TEMPLATES_SUCCESS]: (\n        state,\n        action: HasPayload<{ template_file: string }[]>\n    ) => ({\n        ...state,\n        all: action.payload,\n    }),\n});\n","import {\n    FETCH_POSTINGS_SUCCESS,\n    FETCH_ONE_POSTING_SUCCESS,\n    UPSERT_ONE_POSTING_SUCCESS,\n    DELETE_ONE_POSTING_SUCCESS,\n} from \"../constants\";\nimport { RawPosting } from \"../defs/types\";\nimport { createBasicReducerObject, createReducer } from \"./utils\";\n\ninterface PostingState {\n    _modelData: RawPosting[];\n}\nconst initialState: PostingState = {\n    _modelData: [],\n};\n\n// basicReducers is an object whose keys are FETCH_SESSIONS_SUCCESS, etc,\n// and values are the corresponding reducer functions\nconst basicReducers = createBasicReducerObject<RawPosting>(\n    FETCH_POSTINGS_SUCCESS,\n    FETCH_ONE_POSTING_SUCCESS,\n    UPSERT_ONE_POSTING_SUCCESS,\n    DELETE_ONE_POSTING_SUCCESS\n);\n\nexport const postingsReducer = createReducer(initialState, basicReducers);\n","import {\n    FETCH_POSTING_POSITIONS_SUCCESS,\n    FETCH_ONE_POSTING_POSITION_SUCCESS,\n    UPSERT_ONE_POSTING_POSITION_SUCCESS,\n    DELETE_ONE_POSTING_POSITION_SUCCESS,\n} from \"../constants\";\nimport { RawPostingPosition } from \"../defs/types\";\nimport { createReducer, HasPayload } from \"./utils\";\n\ninterface PositionPostingState {\n    _modelData: RawPostingPosition[];\n}\nconst initialState: PositionPostingState = {\n    _modelData: [],\n};\n\nexport function upsertItem(\n    modelData: RawPostingPosition[],\n    newItem: RawPostingPosition\n): RawPostingPosition[] {\n    let didUpdate = false;\n    const newModelData = modelData.map((item) => {\n        if (\n            item.position_id === newItem.position_id &&\n            item.posting_id === newItem.posting_id\n        ) {\n            didUpdate = true;\n            return newItem;\n        }\n        return item;\n    });\n    if (!didUpdate) {\n        newModelData.push(newItem);\n    }\n    return newModelData;\n}\n\n// PositionPostings have no `id` field, but they are uniquely determined\n// by their `position_id` adn `posting_id`. So, we need to create custom\n// reducer functions.\nexport const postingPositionsReducer = createReducer(initialState, {\n    [FETCH_POSTING_POSITIONS_SUCCESS]: (\n        state: PositionPostingState,\n        action: HasPayload<RawPostingPosition[]>\n    ) => ({\n        ...state,\n        _modelData: action.payload,\n    }),\n    [FETCH_ONE_POSTING_POSITION_SUCCESS]: (\n        state: PositionPostingState,\n        action: HasPayload<RawPostingPosition>\n    ) => ({\n        ...state,\n        _modelData: upsertItem(state._modelData, action.payload),\n    }),\n    [UPSERT_ONE_POSTING_POSITION_SUCCESS]: (\n        state: PositionPostingState,\n        action: HasPayload<RawPostingPosition>\n    ) => ({\n        ...state,\n        _modelData: upsertItem(state._modelData, action.payload),\n    }),\n    [DELETE_ONE_POSTING_POSITION_SUCCESS]: (\n        state: PositionPostingState,\n        action: HasPayload<RawPostingPosition>\n    ) => {\n        const deletedItem = action.payload;\n        return {\n            ...state,\n            _modelData: state._modelData.filter(\n                (item) =>\n                    !(\n                        item.position_id === deletedItem.position_id &&\n                        item.posting_id === deletedItem.posting_id\n                    )\n            ),\n        };\n    },\n});\n","import {\n    FETCH_USERS_SUCCESS,\n    FETCH_ACTIVE_USER_SUCCESS,\n    SET_ACTIVE_USER_ROLE_SUCCESS,\n} from \"../constants\";\nimport type { ActiveUser, User, UserRole } from \"../defs/types\";\nimport { createReducer } from \"./utils\";\n\nexport interface UsersState {\n    users: User[];\n    active_user: ActiveUser | {};\n    active_role: UserRole | null;\n}\n\nconst initialState: UsersState = {\n    users: [],\n    active_user: {},\n    active_role: null,\n};\n\nexport const usersReducer = createReducer(initialState, {\n    [FETCH_ACTIVE_USER_SUCCESS]: (state, action) => ({\n        ...state,\n        active_user: action.payload,\n    }),\n    [FETCH_USERS_SUCCESS]: (state, action) => ({\n        ...state,\n        users: action.payload,\n    }),\n    [SET_ACTIVE_USER_ROLE_SUCCESS]: (state, action) => ({\n        ...state,\n        active_role: action.payload,\n    }),\n});\n","export const SET_SELECTED_ROWS = \"SET_SELECTED_ROWS\";\n","export const SET_SELECTED_DDAH_TABLE_ROWS = \"SET_SELECTED_DDAH_TABLE_ROWS\";\n","export const SET_SELECTED_POSITION = \"SET_SELECTED_POSITION\";\n","import { SET_SELECTED_ROWS } from \"./constants\";\nimport { createReducer } from \"redux-create-reducer\";\n\ninterface OfferTableState {\n    selectedAssignmentIds: number[];\n}\n\n// initialize the state of offer table\nconst initialState: OfferTableState = {\n    selectedAssignmentIds: [],\n};\n\nconst offerTableReducer = createReducer(initialState, {\n    [SET_SELECTED_ROWS]: (state, action) => {\n        return { ...state, selectedAssignmentIds: action.payload };\n    },\n});\n\nexport default offerTableReducer;\n","import { SET_SELECTED_DDAH_TABLE_ROWS } from \"./constants\";\nimport { createReducer } from \"redux-create-reducer\";\n\n// initialize the state of offer table\nconst initialState = {\n    selectedDdahIds: [] as number[],\n};\n\nconst ddahsTableReducer = createReducer(initialState, {\n    [SET_SELECTED_DDAH_TABLE_ROWS]: (state: any, action: any) => {\n        return { ...state, selectedDdahIds: action.payload };\n    },\n});\n\nexport type DdahsTableType = typeof initialState;\n\nexport default ddahsTableReducer;\n","import { SET_SELECTED_POSITION } from \"./constants\";\nimport { createReducer } from \"redux-create-reducer\";\n\ninterface PositionsTableState {\n    selectedPositionIds: number | null;\n}\n\n// initialize the state of offer table\nconst initialState: PositionsTableState = {\n    selectedPositionIds: null,\n};\n\nconst positionsTableReducer = createReducer(initialState, {\n    [SET_SELECTED_POSITION]: (state, action) => {\n        return { ...state, selectedPositionIds: action.payload };\n    },\n});\n\nexport default positionsTableReducer;\n","import { reducer as notificationReducer } from \"react-notification-system-redux\";\nimport { combineReducers } from \"./api/reducers/utils\";\nimport { globalReducer } from \"./api/reducers/globals\";\nimport offerTableReducer from \"./views/admin/offertable/reducers\";\nimport {\n    statusReducer,\n    sessionsReducer,\n    positionsReducer,\n    applicantsReducer,\n    applicationsReducer,\n    assignmentsReducer,\n    instructorsReducer,\n    contractTemplatesReducer,\n    ddahsReducer,\n    postingsReducer,\n    postingPositionsReducer,\n} from \"./api/reducers\";\nimport { usersReducer } from \"./api/reducers/users\";\nimport ddahsTableReducer from \"./views/admin/ddah-table/reducers\";\nimport positionsTableReducer from \"./views/admin/positions/reducers\";\n\n// When `combineReducers` is used,\n// every action gets dispatched to every reducer.\n// Since reducers don't change the state on unrecognized\n// actions, this is okay. Further, each reducer believes\n// it has its own top-level state, but in reality it is\n// just passed a part of the whole state. E.g., if `combineReducers`\n// is passed\n//   {\n//      mypath: myReducer\n//   }\n// When `myReducer(localState)` is called, `localSate == globalState.mypath`.\nconst reducer = combineReducers({\n    model: combineReducers({\n        status: statusReducer,\n        sessions: sessionsReducer,\n        positions: positionsReducer,\n        applicants: applicantsReducer,\n        applications: applicationsReducer,\n        assignments: assignmentsReducer,\n        instructors: instructorsReducer,\n        contractTemplates: contractTemplatesReducer,\n        postings: postingsReducer,\n        postingPositions: postingPositionsReducer,\n        users: usersReducer,\n        ddahs: ddahsReducer,\n    }),\n    ui: combineReducers({\n        notifications: notificationReducer,\n        offerTable: offerTableReducer,\n        ddahsTable: ddahsTableReducer,\n        positionsTable: positionsTableReducer,\n        globals: globalReducer,\n    }),\n});\n\nexport type RootState = ReturnType<typeof reducer>;\nexport default reducer;\n","import { createStore, applyMiddleware } from \"redux\";\nimport { composeWithDevTools } from \"redux-devtools-extension\";\nimport { persistStore, persistReducer } from \"redux-persist\";\nimport storage from \"redux-persist/lib/storage\";\nimport rootReducer from \"./rootReducer\";\nimport thunk from \"redux-thunk\";\n\n/* eslint-disable */\nconst configureStore = () => {\n    const persistConfig = {\n        key: \"root\",\n        storage,\n        whitelist: [\"auth\", \"application\"],\n    };\n    const persistedReducer = persistReducer(persistConfig, rootReducer);\n    const store = createStore(\n        persistedReducer,\n        composeWithDevTools(applyMiddleware(thunk))\n    );\n    const persistor = persistStore(store);\n\n    if (process.env.NODE_ENV !== \"production\") {\n        if (module.hot) {\n            module.hot.accept(\"./rootReducer\", () => {\n                store.replaceReducer(persistedReducer);\n            });\n        }\n    }\n\n    return { store, persistor };\n};\n/* eslint-enable */\n\nexport default configureStore;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Provider } from \"react-redux\";\nimport { HashRouter } from \"react-router-dom\";\nimport { PersistGate } from \"redux-persist/integration/react\";\nimport DynamicEntryRouter from \"./dynamic-entry-router\";\nimport configureStore from \"./store\";\n\nconst { store, persistor } = configureStore();\n\n// In production, we don't want to wrap the app in a dev frame,\n// but we do want to in development\nlet DevFrame = function (props: any) {\n    return <React.Fragment>{props.children}</React.Fragment>;\n};\nif (process.env.REACT_APP_DEV_FEATURES) {\n    // We only want to load the dev frame parts if they are needed,\n    // so we use React.lazy to load them on demand.\n    const FullDevFrame = React.lazy(async () =>\n        import(\"./views/dev_frame\").then((module) => ({\n            // Because `React.lazy` expects a default export, we need to fake\n            // the default export in the case of a named export.\n            default: module.DevFrame,\n        }))\n    );\n    DevFrame = function (props) {\n        return (\n            <React.Suspense fallback=\"Loading...\">\n                <FullDevFrame>{props.children}</FullDevFrame>\n            </React.Suspense>\n        );\n    };\n}\n\nconst render = (Component: React.ElementType) => {\n    return ReactDOM.render(\n        <HashRouter>\n            <Provider store={store}>\n                <PersistGate persistor={persistor}>\n                    <DevFrame>\n                        <div id=\"app-body\">\n                            <Component />\n                        </div>\n                    </DevFrame>\n                </PersistGate>\n            </Provider>\n        </HashRouter>,\n        document.getElementById(\"root\")\n    );\n};\n\nrender(DynamicEntryRouter);\n\n// Hot module reloading\n// https://medium.com/@brianhan/hot-reloading-cra-without-eject-b54af352c642\n\n/*eslint-disable */\nif (\"hot\" in module) {\n    (module as any).hot.accept(\"./dynamic-entry-router\", () => {\n        const NextApp = require(\"./dynamic-entry-router\").default;\n        render(NextApp);\n    });\n}\n/*eslint-enable */\n"],"sourceRoot":""}